<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TORO Navi by Salmon</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #map-container {
            position: relative;
            flex-grow: 1;
            display: flex;
            overflow: visible;
            width: 100%;
            height: 100%;
        }
        #map {
            position: absolute;
            background-color: #e4e4e4;
            transform-origin: center center;
            will-change: transform;
            transition: transform 0.2s ease-out;
        }
        .leaflet-marker-icon.tracked-player {
            z-index: 1000 !important;
        }
        .leaflet-marker-icon {
            transform-origin: center center;
        }
        #player-controls {
            padding: 10px;
            background-color: rgba(233, 233, 233, 0.9);
            display: flex;
            gap: 10px;
            align-items: center;
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #player-controls label {
            font-weight: bold;
        }
        #trackPlayerButton {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #trackPlayerButton:hover {
            background-color: #45a049;
        }
        #show-all-players-label {
            margin-left: auto;
        }
        #info-panel {
            width: 300px;
            max-height: 70vh;
            padding: 15px;
            overflow-y: auto;
            background-color: rgba(249, 249, 249, 0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            border-radius: 5px;
        }
        #info-panel h2, #info-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        #info-panel p {
            margin: 5px 0;
            font-size: 0.9em;
        }
        #nearby-facilities {
            list-style-type: none;
            padding-left: 0;
        }
        #nearby-facilities li {
            padding: 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
        }
        #nearby-facilities li:last-child {
            border-bottom: none;
        }
        #nearby-facilities img {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }
        .loading-message, .error-message, .status-message {
            text-align: center;
            padding: 10px;
            font-style: italic;
            color: #444;
        }
        .error-message {
            color: #d9534f;
        }
        .warning-message {
            color: #ff9800;
        }
        .player-input {
            padding: 5px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
            background-color: white;
        }
        .leaflet-tooltip.dynmap-marker-label,
        .leaflet-tooltip.player-label {
            background-color: transparent;
            border: none;
            box-shadow: none;
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black;
            white-space: nowrap;
            padding: 0;
            margin: 0;
            pointer-events: none;
            transform-origin: center bottom;
            display: block !important;
            text-align: center;
        }
        .leaflet-tooltip.hidden-label {
            display: none !important;
        }
        .leaflet-tooltip.dynmap-marker-label::before,
.leaflet-tooltip.player-label::before,
.leaflet-tooltip.dynmap-marker-label::after,
.leaflet-tooltip.player-label::after {
    display: none !important;
}
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map">
            <div class="loading-message">マップデータを読み込み中...</div>
        </div>
        <div id="player-controls">
            <div class="controls">
                <label for="playerNameSelect">追跡するプレイヤー:</label>
                <select id="playerNameSelect" class="player-input">
                    <option value="">プレイヤーを選択</option>
                </select>
                <button id="trackPlayerButton" style="display: none;">追跡開始</button>
                <label>他のプレイヤーを表示<input type="checkbox" id="showAllPlayersCheckbox"></label>
            </div>
            <label id="show-labels-label" for="show-labels-checkbox">ラベル表示:</label>
            <input type="checkbox" id="show-labels-checkbox" checked>
        </div>
        <div id="info-panel">
            <h2>TORO Navi by Salmon</h2>
            <p>追跡中のプレイヤー: <span id="tracked-player-name">-</span></p>
            <p>プレイヤー座標 (Dynmap): <span id="player-dynmap-coords">-</span></p>
            <p>ワールド: <span id="player-world">-</span></p>
            <p>走行中の道路: <span id="current-road">-</span></p>
            <h3>近くの施設:</h3>
            <ul id="nearby-facilities">
                <li>プレイヤーを追跡していません。</li>
            </ul>
            <div id="status-message-area" class="status-message"></div>
        </div>
    </div>

    <script>
        // --- 設定項目 ---
        const DYNMAP_SERVER_ADDRESS = 'https://map.torosaba.net';
        const DYNMAP_WORLD_NAME = 'main';
        const DYNMAP_MARKERS_API_ENDPOINT = `${DYNMAP_SERVER_ADDRESS}/tiles/_markers_/marker_${DYNMAP_WORLD_NAME}.json`;
        const DYNMAP_UPDATE_API_ENDPOINT = `${DYNMAP_SERVER_ADDRESS}/up/world/${DYNMAP_WORLD_NAME}/`;
        const PLAYER_TRACKING_INTERVAL = 1000;
        const DYNMAP_ICON_BASE_URL = `${DYNMAP_SERVER_ADDRESS}/tiles/_markers_/`;
        const PLAYER_ARROW_ICON_URL = 'icon.png';
        const DYNMAP_MIN_NATIVE_ZOOM = 0;
        const DYNMAP_MAX_NATIVE_ZOOM = 5;
        const LEAFLET_MIN_ZOOM = 0;
        const LEAFLET_MAX_ZOOM = DYNMAP_MAX_NATIVE_ZOOM - DYNMAP_MIN_NATIVE_ZOOM + 5;
        const DYNMAP_INITIAL_LEAFLET_ZOOM = 1;

        // --- グローバル変数 ---
        let map;
        let playerMarker;
        let dynmapPinsLayer = L.layerGroup();
        let dynmapLinesLayer = L.layerGroup();
        let allPlayersLayer = L.layerGroup();
        let allPinsData = [];
        let allLinesData = [];
        let trackedPlayerNameGlobal = null;
        let playerTrackingIntervalId = null;
        let lastKnownPlayerDynmapCoords = null;
        let previousTrackedPlayerPosition = null;
        let otherPlayerMarkers = {};
        let isFollowingPlayer = false;
        let programmaticMove = false;
        let currentMapRotation = 0;

        // DOM要素
        let mapContainer;
        let mapDiv;
        let loadingMessageMap;
        let trackPlayerButton;
        let showAllPlayersCheckbox;
        let showLabelsCheckbox;
        const trackedPlayerNameDisplay = document.getElementById('tracked-player-name');
        const playerDynmapCoordsDisplay = document.getElementById('player-dynmap-coords');
        const playerWorldDisplay = document.getElementById('player-world');
        const roadDisplay = document.getElementById('current-road');
        const facilitiesList = document.getElementById('nearby-facilities');
        const statusMessageArea = document.getElementById('status-message-area');

        // --- 初期化 ---
        document.addEventListener('DOMContentLoaded', async () => {
            mapContainer = document.getElementById('map-container');
            mapDiv = document.getElementById('map');
            loadingMessageMap = mapDiv.querySelector('.loading-message');
            trackPlayerButton = document.getElementById('trackPlayerButton');
            showAllPlayersCheckbox = document.getElementById('showAllPlayersCheckbox');
            showLabelsCheckbox = document.getElementById('show-labels-checkbox');

            try {
                
                map = L.map('map', {
                    crs: L.CRS.Simple,
                    minZoom: LEAFLET_MIN_ZOOM,
                    maxZoom: LEAFLET_MAX_ZOOM,
                }).setView([0, 0], DYNMAP_INITIAL_LEAFLET_ZOOM);
                
                /* Dynmapのタイル表示は未実装
                L.tileLayer(`${DYNMAP_SERVER_ADDRESS}/tiles/${DYNMAP_WORLD_NAME}/flat/{z}/{x}_{y}.png`, {
                    minZoom: DYNMAP_MIN_NATIVE_ZOOM,
                    maxZoom: DYNMAP_MAX_NATIVE_ZOOM,
                    tileSize: 128,
                    noWrap: true,
                    bounds: L.latLngBounds(dynmapToLeafletCoords(-20000, -20000), dynmapToLeafletCoords(20000, 20000))
                }).addTo(map);
                */
                dynmapPinsLayer.addTo(map);
                dynmapLinesLayer.addTo(map);
                allPlayersLayer.addTo(map);

                await loadDynmapStaticData();
                centerMapOnSpawn();
                if (loadingMessageMap) loadingMessageMap.style.display = 'none';

            } catch (error) {
                console.error("マップ初期化エラー:", error);
                if (loadingMessageMap) loadingMessageMap.textContent = "マップの読み込みに失敗しました。";
                mapDiv.innerHTML = `<div class="error-message">マップの初期化に失敗しました: ${error.message}</div>`;
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const playerName = urlParams.get('MCID')?.trim();

            showAllPlayersCheckbox.checked = true;

            if (playerName) {
                console.log(`URLパラメータからプレイヤーを自動追跡: ${playerName}`);
                if (playerTrackingIntervalId) {
                    clearInterval(playerTrackingIntervalId);
                    playerTrackingIntervalId = null;
                }
                if (playerMarker) {
                    playerMarker.remove();
                    playerMarker = null;
                    console.log(`${trackedPlayerNameGlobal} の以前のプレイヤーマーカーをクリアしました。`);
                }

                trackedPlayerNameGlobal = playerName;
                isFollowingPlayer = true;
                previousTrackedPlayerPosition = null;
                lastKnownPlayerDynmapCoords = null;
                trackedPlayerNameDisplay.textContent = playerName;
                document.getElementById('playerNameSelect').value = playerName;
                statusMessageArea.textContent = `${playerName} を追跡開始します...`;
                statusMessageArea.className = 'status-message';

                fetchAndUpdatePlayerData();
                playerTrackingIntervalId = setInterval(fetchAndUpdatePlayerData, PLAYER_TRACKING_INTERVAL);
            } else {
                console.log('URLにMCIDパラメータが見つかりませんでした。');
                fetchAndUpdatePlayerData();
            }

            trackPlayerButton.addEventListener('click', handleTrackPlayerButtonClick);
            showAllPlayersCheckbox.addEventListener('change', handleShowAllPlayersChange);
            showLabelsCheckbox.addEventListener('change', toggleLabelsVisibility);

            document.getElementById('playerNameSelect').addEventListener('change', () => {
                if (document.getElementById('playerNameSelect').value) {
                    handleTrackPlayerButtonClick();
                }
            });

            map.on('movestart', function() {
                if (programmaticMove) {
                    programmaticMove = false;
                    return;
                }
                if (isFollowingPlayer) {
                    isFollowingPlayer = false;
                    statusMessageArea.textContent = "マップを動かすと追跡は停止します。";
                    statusMessageArea.className = 'status-message';
                    rotateMap(0);
                    if (trackedPlayerNameGlobal && playerMarker) {
                        fetchAndUpdatePlayerData();
                    }
                }
            });
        });

        // --- ユーティリティ関数 ---
        function dynmapToLeafletCoords(dynmapX, dynmapZ) {
            return [-dynmapZ, dynmapX];
        }

        function setElementCounterRotation(element, degrees, offsetY = 0) {
            if (element) {
                let currentTransform = L.DomUtil.getStyle(element, 'transform') || "";
                if (currentTransform === "none") currentTransform = "";
                let newTransform = currentTransform.replace(/rotate\([^)]+\)/g, '').replace(/translateY\([^)]+\)/g, '').trim();
                if (degrees !== 0) {
                    newTransform += ` rotate(${degrees}deg)`;
                }
                if (offsetY !== 0) {
                    newTransform += ` translateY(${offsetY}px)`;
                }
                element.style.transform = newTransform;
            }
        }

        function applyMarkerCounterRotation() {
            const counterRotationDeg = -currentMapRotation;

            if (playerMarker && playerMarker.getElement()) {
                setElementCounterRotation(playerMarker.getElement(), counterRotationDeg);
            }

            dynmapPinsLayer.eachLayer(layer => {
                if (layer.getElement()) {
                    setElementCounterRotation(layer.getElement(), counterRotationDeg);
                    const tooltipElement = layer.getTooltip() ? layer.getTooltip().getElement() : null;
                    if (tooltipElement) {
                        const iconSize = layer.getIcon().options.iconSize[1] || 16;
                        const offsetY = -iconSize;
                        setElementCounterRotation(tooltipElement, counterRotationDeg, offsetY);
                    }
                }
            });

            allPlayersLayer.eachLayer(layer => {
                if (layer.getElement()) {
                    setElementCounterRotation(layer.getElement(), counterRotationDeg);
                    const tooltipElement = layer.getTooltip() ? layer.getTooltip().getElement() : null;
                    if (tooltipElement) {
                        const iconSize = layer.getIcon().options.iconSize[1] || 24;
                        const offsetY = -iconSize;
                        setElementCounterRotation(tooltipElement, counterRotationDeg, offsetY);
                    }
                }
            });
        }

        function rotateMap(degrees, centerCoords) {
            if (!map || !map.getContainer()) return;

            const mapDivElement = map.getContainer();
            currentMapRotation = (degrees % 360 + 360) % 360;
            
            const containerWidth = mapContainer.offsetWidth;
            const containerHeight = mapContainer.offsetHeight;

            // 現在のコンテナの対角線の長さを計算
            const diagonal = Math.sqrt(containerWidth * containerWidth + containerHeight * containerHeight);

            // 回転時に必ず表示領域をカバーするのに必要なサイズを計算
            // 最もシンプルな方法として、対角線の長さでマップの幅と高さを設定する
            const requiredSize = diagonal * 1.05; // 少し余裕を持たせる (5%増し)

            mapDivElement.style.width = `${requiredSize}px`;
            mapDivElement.style.height = `${requiredSize}px`;

            // マップ要素をコンテナの中央に配置
            mapDivElement.style.left = `${(containerWidth - requiredSize) / 2}px`;
            mapDivElement.style.top = `${(containerHeight - requiredSize) / 2}px`;
            
            const absCos = Math.abs(Math.cos(degrees * Math.PI / 180));
            const absSin = Math.abs(Math.sin(degrees * Math.PI / 180));
            const scaleFactor = 1 / Math.max(absCos, absSin, 1);
            const boundedScale = Math.min(scaleFactor, 1.414);

            mapDivElement.style.transform = `rotate(${degrees}deg) scale(${boundedScale})`;
            mapDivElement.style.transformOrigin = 'center center';

            map.invalidateSize(false);

            if (isFollowingPlayer && centerCoords) {
                programmaticMove = true;
                map.setView(centerCoords, map.getZoom(), { animate: true, duration: 0.3 });
            }

            applyMarkerCounterRotation();
            console.log(`Map rotated to ${degrees}deg, scale: ${boundedScale}, center: ${centerCoords ? JSON.stringify(centerCoords) : 'none'}`);
        }

        function toggleLabelsVisibility() {
            const showLabels = showLabelsCheckbox.checked;
            const labelClass = 'hidden-label';

            if (playerMarker && playerMarker.getTooltip()) {
                const tooltipElement = playerMarker.getTooltip().getElement();
                if (tooltipElement) {
                    tooltipElement.classList.toggle(labelClass, !showLabels);
                }
            }

            dynmapPinsLayer.eachLayer(layer => {
                if (layer.getTooltip()) {
                    const tooltipElement = layer.getTooltip().getElement();
                    if (tooltipElement) {
                        tooltipElement.classList.toggle(labelClass, !showLabels);
                    }
                }
            });

            allPlayersLayer.eachLayer(layer => {
                if (layer.getTooltip()) {
                    const tooltipElement = layer.getTooltip().getElement();
                    if (tooltipElement) {
                        tooltipElement.classList.toggle(labelClass, !showLabels);
                    }
                }
            });
        }

        function updatePlayerSelectList(players) {
            const select = document.getElementById('playerNameSelect');
            const currentValue = select.value;

            while (select.options.length > 1) {
                select.remove(1);
            }

            if (players && players.length > 0) {
                players.forEach(player => {
                    const option = document.createElement('option');
                    option.value = player.name || player.account;
                    option.text = player.name || player.account;
                    select.appendChild(option);
                });
                statusMessageArea.textContent = '';
                statusMessageArea.className = '';
            } else {
                statusMessageArea.textContent = 'オンラインのプレイヤーがいません。';
                statusMessageArea.className = 'warning-message';
            }

            if (trackedPlayerNameGlobal) {
                const optionExists = Array.from(select.options).some(opt => opt.value === trackedPlayerNameGlobal);
                if (!optionExists) {
                    const option = document.createElement('option');
                    option.value = trackedPlayerNameGlobal;
                    option.text = trackedPlayerNameGlobal + ' (オフライン)';
                    select.appendChild(option);
                }
                select.value = trackedPlayerNameGlobal;
            } else {
                select.value = '';
            }

            console.log(`Updated player select list. Selected: ${select.value}`);
        }

        // --- データ処理 ---
        async function loadDynmapStaticData() {
            try {
                const response = await fetch(DYNMAP_MARKERS_API_ENDPOINT);
                if (!response.ok) throw new Error(`マーカー取得失敗: ${response.statusText}`);
                const rawMarkerData = await response.json();
                parseAndStoreDynmapMarkers(rawMarkerData);
                displayDynmapFeatures();
                if (loadingMessageMap) loadingMessageMap.style.display = 'none';
            } catch (error) {
                console.error('Dynmap静的データエラー:', error);
                statusMessageArea.textContent = `マーカー読込エラー: ${error.message}`;
                statusMessageArea.className = 'error-message';
                if (loadingMessageMap) loadingMessageMap.textContent = "データ読み込みエラー";
            }
        }

        function formatColor(colorValue, defaultColor) {
            if (typeof colorValue === 'string' && colorValue.startsWith('#')) {
                return colorValue;
            } else if (typeof colorValue === 'number') {
                return `#${colorValue.toString(16).padStart(6, '0')}`;
            }
            return defaultColor;
        }

        function parseAndStoreDynmapMarkers(rawData) {
            allPinsData = [];
            allLinesData = [];
            let parsedPinsCount = 0;
            let parsedLinesCount = 0;
            let parsedAreasCount = 0;

            if (!rawData || !rawData.sets) {
                console.error("Marker data is invalid or missing 'sets' property:", rawData);
                return;
            }

            for (const setName in rawData.sets) {
                const set = rawData.sets[setName];
                if (!set) continue;

                if (set.markers) {
                    for (const markerId in set.markers) {
                        const marker = set.markers[markerId];
                        if (marker && typeof marker.x === 'number' && typeof marker.y === 'number' && typeof marker.z === 'number') {
                            allPinsData.push({
                                id: markerId, x: marker.x, y: marker.y, z: marker.z,
                                label: marker.label || marker.markup || markerId,
                                icon: marker.icon || 'default'
                            });
                            parsedPinsCount++;
                        }
                    }
                }
                if (set.lines) {
                    for (const lineId in set.lines) {
                        const line = set.lines[lineId];
                        if (line && Array.isArray(line.x) && Array.isArray(line.y) && Array.isArray(line.z) &&
                            line.x.length === line.y.length && line.x.length === line.z.length && line.x.length > 1) {
                            const points = [];
                            for (let i = 0; i < line.x.length; i++) {
                                if (typeof line.x[i] === 'number' && typeof line.y[i] === 'number' && typeof line.z[i] === 'number') {
                                    points.push({ x: line.x[i], y: line.y[i], z: line.z[i] });
                                }
                            }
                            if (points.length === line.x.length) {
                                allLinesData.push({
                                    id: lineId, points: points, label: line.label || line.desc || lineId,
                                    color: formatColor(line.color, '#FFFFFF'),
                                    weight: line.weight || 2
                                });
                                parsedLinesCount++;
                            }
                        }
                    }
                }
                if (set.areas) {
                    for (const areaId in set.areas) {
                        const area = set.areas[areaId];
                        if (area && Array.isArray(area.x) && Array.isArray(area.z) &&
                            area.x.length === area.z.length && area.x.length > 1) {
                            const points = [];
                            const defaultY = typeof area.ybottom === 'number' ? area.ybottom : (typeof area.ytop === 'number' ? area.ytop : 64);
                            for (let i = 0; i < area.x.length; i++) {
                                if (typeof area.x[i] === 'number' && typeof area.z[i] === 'number') {
                                    points.push({ x: area.x[i], y: defaultY, z: area.z[i] });
                                }
                            }
                            if (points.length === area.x.length) {
                                let closedPoints = [...points];
                                if (closedPoints.length > 2 && (closedPoints[0].x !== closedPoints[closedPoints.length - 1].x || closedPoints[0].z !== closedPoints[closedPoints.length - 1].z)) {
                                    closedPoints.push(closedPoints[0]);
                                }
                                allLinesData.push({
                                    id: areaId, points: closedPoints, label: area.label || area.desc || areaId,
                                    color: formatColor(area.strokecolor || area.color, '#AAAAAA'),
                                    weight: area.strokeweight || area.weight || 1,
                                    isAreaOutline: true
                                });
                                parsedAreasCount++;
                            }
                        }
                    }
                }
            }
        }

        function displayDynmapFeatures() {
            dynmapPinsLayer.clearLayers();
            allPinsData.forEach(pin => {
                const coords = dynmapToLeafletCoords(pin.x, pin.z);
                const iconUrl = `${DYNMAP_ICON_BASE_URL}${pin.icon}.png`;
                const dynmapIcon = L.icon({
                    iconUrl: iconUrl,
                    iconSize: [16, 16], iconAnchor: [8, 8], popupAnchor: [0, -8]
                });
                L.marker(coords, { icon: dynmapIcon })
                    .bindPopup(`<b>${pin.label}</b><br>座標: X:${pin.x.toFixed(0)}, Y:${pin.y.toFixed(0)}, Z:${pin.z.toFixed(0)}`)
                    .bindTooltip(pin.label, {
                        permanent: true,
                        direction: 'top',
                        className: 'dynmap-marker-label',
                        offset: [0, 0]
                        
                    })
                    .addTo(dynmapPinsLayer)
                    .on('error', function(e) { this.setIcon(new L.Icon.Default()); });
            });

            dynmapLinesLayer.clearLayers();
            allLinesData.forEach((line) => {
                if (!line || !Array.isArray(line.points) || line.points.length < 2) return;
                const latLngs = line.points.map(p => dynmapToLeafletCoords(p.x, p.z));
                try {
                    L.polyline(latLngs, { color: line.color, weight: line.weight })
                        .bindPopup(line.label || `Line ${line.id}`)
                        .addTo(dynmapLinesLayer);
                } catch (e) {
                    console.error(`Error drawing polyline for line (id: ${line.id}):`, line, e);
                }
            });
            applyMarkerCounterRotation();
        }

        function handleTrackPlayerButtonClick() {
            const playerName = document.getElementById('playerNameSelect').value.trim();
            if (!playerName) {
                statusMessageArea.textContent = "プレイヤーを選択してください。";
                statusMessageArea.className = 'error-message';
                return;
            }

            if (playerTrackingIntervalId) {
                clearInterval(playerTrackingIntervalId);
                playerTrackingIntervalId = null;
            }
            if (playerMarker) {
                playerMarker.remove();
                playerMarker = null;
                console.log(`Cleared previous playerMarker for ${trackedPlayerNameGlobal}`);
            }

            trackedPlayerNameGlobal = playerName;
            isFollowingPlayer = true;
            previousTrackedPlayerPosition = null;
            lastKnownPlayerDynmapCoords = null;
            trackedPlayerNameDisplay.textContent = playerName;
            document.getElementById('playerNameSelect').value = playerName;
            statusMessageArea.textContent = `${playerName} を追跡開始します...`;
            statusMessageArea.className = 'status-message';
            console.log(`Started tracking from UI: ${playerName}`);

            fetchAndUpdatePlayerData();
            playerTrackingIntervalId = setInterval(fetchAndUpdatePlayerData, PLAYER_TRACKING_INTERVAL);
        }

        function handleShowAllPlayersChange() {
            if (!showAllPlayersCheckbox.checked) {
                allPlayersLayer.clearLayers();
                otherPlayerMarkers = {};
            }
            fetchAndUpdatePlayerData();
        }

        async function fetchAndUpdatePlayerData() {
            if (!trackedPlayerNameGlobal && !showAllPlayersCheckbox.checked) {
                console.log('No player tracked and no other players to show.');
                return;
            }

            let updateData;
            try {
                const response = await fetch(`${DYNMAP_UPDATE_API_ENDPOINT}?_=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`プレイヤーデータ取得失敗: ${response.statusText}`);
                updateData = await response.json();
                console.log('Player data:', updateData.players);

                updatePlayerSelectList(updateData.players);

            } catch (error) {
                console.error('プレイヤーデータ更新エラー:', error);
                statusMessageArea.textContent = `エラー: ${error.message}`;
                statusMessageArea.className = 'error-message';
                updatePlayerSelectList([]);
                return;
            }

            if (trackedPlayerNameGlobal) {
                const playerData = updateData.players.find(p => p.name === trackedPlayerNameGlobal || p.account === trackedPlayerNameGlobal);

                if (playerData) {
                    if (playerData.world !== DYNMAP_WORLD_NAME) {
                        statusMessageArea.textContent = `${trackedPlayerNameGlobal} はワールド '${playerData.world}' にいます。(対象: '${DYNMAP_WORLD_NAME}')`;
                        statusMessageArea.className = 'error-message';
                        if (playerMarker) {
                            playerMarker.remove();
                            playerMarker = null;
                        }
                        lastKnownPlayerDynmapCoords = null;
                        clearPlayerSpecificInfo();
                        rotateMap(0);
                        previousTrackedPlayerPosition = null;
                    } else {
                        lastKnownPlayerDynmapCoords = { x: playerData.x, y: playerData.y, z: playerData.z, world: playerData.world, yaw: playerData.yaw };
                        playerDynmapCoordsDisplay.textContent = `X:${playerData.x.toFixed(0)}, Y:${playerData.y.toFixed(0)}, Z:${playerData.z.toFixed(0)}`;
                        playerWorldDisplay.textContent = playerData.world;

                        const leafletCoords = dynmapToLeafletCoords(playerData.x, playerData.z);
                        let playerIcon;

                        if (isFollowingPlayer) {
                            statusMessageArea.textContent = `${trackedPlayerNameGlobal} の位置更新完了。`;
                            playerIcon = L.icon({
                                iconUrl: PLAYER_ARROW_ICON_URL,
                                iconSize: [48, 48],
                                iconAnchor: [16, 16],
                                popupAnchor: [0, -16],
                                className: 'tracked-player'
                            });

                            const imgTest = new Image();
                            imgTest.onload = function() {};
                            imgTest.onerror = function() {
                                console.warn(`カスタム矢印アイコン ${PLAYER_ARROW_ICON_URL} が見つかりません。スキンアイコンにフォールバックします。`);
                                playerIcon = L.icon({
                                    iconUrl: `https://mc-heads.net/avatar/${playerData.account}`,
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 12],
                                    popupAnchor: [0, -12],
                                    className: 'tracked-player'
                                });
                                if (playerMarker) playerMarker.setIcon(playerIcon);
                            };
                            imgTest.src = PLAYER_ARROW_ICON_URL;

                            let mapRotationDeg = currentMapRotation;
                            if (previousTrackedPlayerPosition &&
                                (Math.abs(playerData.x - previousTrackedPlayerPosition.x) > 0.1 || Math.abs(playerData.z - previousTrackedPlayerPosition.z) > 0.1)) {
                                const deltaX = playerData.x - previousTrackedPlayerPosition.x;
                                const deltaZ = playerData.z - previousTrackedPlayerPosition.z;
                                const moveAngleRad = Math.atan2(-deltaZ, -deltaX);
                                mapRotationDeg = -(moveAngleRad * (180 / Math.PI) - 90);
                                mapRotationDeg = (mapRotationDeg % 360 + 360) % 360;
                            } else if (!previousTrackedPlayerPosition && typeof playerData.yaw === 'number' && !isNaN(playerData.yaw)) {
                                mapRotationDeg = -(playerData.yaw - 90);
                                mapRotationDeg = (mapRotationDeg % 360 + 360) % 360;
                            }
                            rotateMap(mapRotationDeg, leafletCoords);
                        } else {
                            playerIcon = L.icon({
                                iconUrl: `https://mc-heads.net/avatar/${playerData.account}`,
                                iconSize: [24, 24],
                                iconAnchor: [12, 12],
                                popupAnchor: [0, -12],
                                className: 'tracked-player'
                            });
                            rotateMap(0);
                        }

                        if (!playerMarker) {
                            playerMarker = L.marker(leafletCoords, {
                                icon: playerIcon,
                                zIndexOffset: 1000
                            }).addTo(map);
                        } else {
                            playerMarker.setLatLng(leafletCoords);
                            playerMarker.setIcon(playerIcon);
                            if (playerMarker.getTooltip()) {
                                playerMarker.closeTooltip();
                                playerMarker.unbindTooltip();
                            }
                        }
                        playerMarker.bindPopup(`<b>${trackedPlayerNameGlobal}</b><br>HP: ${playerData.health || 'N/A'}/${playerData.armor || 0}`);
                        updateInformationPanelForPlayer();
                        previousTrackedPlayerPosition = { x: playerData.x, z: playerData.z };
                    }
                } else {
                    statusMessageArea.textContent = `プレイヤー '${trackedPlayerNameGlobal}' が見つかりません。`;
                    statusMessageArea.className = 'error-message';
                    if (playerMarker) {
                        playerMarker.remove();
                        playerMarker = null;
                    }
                    lastKnownPlayerDynmapCoords = null;
                    clearPlayerSpecificInfo();
                    rotateMap(0);
                    previousTrackedPlayerPosition = null;
                }
            } else {
                clearPlayerSpecificInfo();
                trackedPlayerNameDisplay.textContent = "-";
                if (playerMarker) {
                    playerMarker.remove();
                    playerMarker = null;
                }
                rotateMap(0);
                previousTrackedPlayerPosition = null;
            }

            if (showAllPlayersCheckbox.checked) {
                const currentVisiblePlayers = {};
                updateData.players.forEach(p => {
                    if (p.world === DYNMAP_WORLD_NAME) {
                        if (trackedPlayerNameGlobal && (p.name === trackedPlayerNameGlobal || p.account === trackedPlayerNameGlobal)) {
                            return;
                        }

                        currentVisiblePlayers[p.account] = true;

                        const pCoords = dynmapToLeafletCoords(p.x, p.z);
                        const otherSkinUrl = `https://mc-heads.net/avatar/${p.account}`;
                        const otherPlayerIcon = L.icon({
                            iconUrl: otherSkinUrl,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12],
                            popupAnchor: [0, -12]
                        });

                        if (otherPlayerMarkers[p.account]) {
                            otherPlayerMarkers[p.account].setLatLng(pCoords);
                            otherPlayerMarkers[p.account].setIcon(otherPlayerIcon);
                            otherPlayerMarkers[p.account].setPopupContent(`${p.account}<br>X:${p.x.toFixed(0)}, Y:${p.y.toFixed(0)}, Z:${p.z.toFixed(0)}`);
                            otherPlayerMarkers[p.account].setTooltipContent(p.account);
                        } else {
                            otherPlayerMarkers[p.account] = L.marker(pCoords, {
                                icon: otherPlayerIcon,
                                playerName: p.account
                            })
                                .bindPopup(`${p.account}<br>X:${p.x.toFixed(0)}, Y:${p.y.toFixed(0)}, Z:${p.z.toFixed(0)}`)
                                .bindTooltip(p.account, {
                                    permanent: true,
                                    direction: 'top',
                                    className: 'player-label',
                                    offset: [0, 0]
                                })
                                .addTo(allPlayersLayer);
                        }
                    }
                });
                for (const playerNameKey in otherPlayerMarkers) {
                    if (!currentVisiblePlayers[playerNameKey]) {
                        allPlayersLayer.removeLayer(otherPlayerMarkers[playerNameKey]);
                        delete otherPlayerMarkers[playerNameKey];
                    }
                }
            } else {
                allPlayersLayer.clearLayers();
                otherPlayerMarkers = {};
            }

            applyMarkerCounterRotation();
            toggleLabelsVisibility();
        }

        function centerMapOnSpawn() {
            const spawnMarker = allPinsData.find(pin =>
                pin.label.toLowerCase().includes('spawn') || pin.label.toLowerCase().includes('ワールドスポーン')
            );

            if (spawnMarker) {
                const spawnLatLng = dynmapToLeafletCoords(spawnMarker.x, spawnMarker.z);
                map.setView(spawnLatLng, LEAFLET_MIN_ZOOM, { animate: true, duration: 1.0 });
            } else {
                console.warn("Spawnマーカーが見つかりませんでした。マップはデフォルトの中心に留まります。");
                statusMessageArea.textContent = "Spawnマーカーが見つかりませんでした。";
                map.setView(dynmapToLeafletCoords(0, 0), DYNMAP_INITIAL_LEAFLET_ZOOM);
            }
        }

        function updateInformationPanelForPlayer() {
            if (!lastKnownPlayerDynmapCoords) {
                roadDisplay.textContent = 'プレイヤー位置不明';
                facilitiesList.innerHTML = '<li>プレイヤー位置特定不能</li>'; return;
            }
            const playerX = lastKnownPlayerDynmapCoords.x;
            const playerZ = lastKnownPlayerDynmapCoords.z;
            const currentRoad = findCurrentRoad(playerX, playerZ, allLinesData);
            roadDisplay.textContent = currentRoad ? currentRoad.label : '近くに認識できる道路なし';
            const nearbyFacilities = findNearbyFacilities(playerX, playerZ, allPinsData, 150);
            displayNearbyFacilities(nearbyFacilities);
        }

        function findCurrentRoad(userX, userZ, lines) {
            let closestRoad = null; let minDistance = Infinity; const threshold = 25;
            lines.filter(line => !line.isAreaOutline).forEach(line => {
                if (!line.points || line.points.length < 2) return;
                for (let i = 0; i < line.points.length - 1; i++) {
                    const dist = distanceToSegment({x: userX, z: userZ}, line.points[i], line.points[i+1]);
                    if (dist < minDistance) { minDistance = dist; if (minDistance < threshold) closestRoad = line; }
                }
            });
            return closestRoad;
        }
        function sqr(x) { return x * x }
        function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.z - w.z) }
        function distanceToSegmentSquared(p, v, w) {
            const l2 = dist2(v, w); if (l2 === 0) return dist2(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.z - v.z) * (w.z - v.z)) / l2;
            t = Math.max(0, Math.min(1, t));
            return dist2(p, { x: v.x + t * (w.x - v.x), z: v.z + t * (w.z - v.z) });
        }
        function distanceToSegment(p, v, w) { return Math.sqrt(distanceToSegmentSquared(p, v, w)); }

        function findNearbyFacilities(userX, userZ, pins, radius) {
            const nearby = pins.map(pin => ({...pin, distance: Math.sqrt(Math.pow(pin.x - userX, 2) + Math.pow(pin.z - userZ, 2))}))
                               .filter(pin => pin.distance <= radius)
                               .sort((a, b) => a.distance - b.distance);
            return nearby;
        }
        function displayNearbyFacilities(facilities) {
            facilitiesList.innerHTML = '';
            if (facilities.length === 0) {
                facilitiesList.innerHTML = '<li>近くに施設はありません。</li>'; return;
            }
            facilities.forEach(facility => {
                const li = document.createElement('li');
                const iconImg = document.createElement('img');
                iconImg.src = `${DYNMAP_ICON_BASE_URL}${facility.icon}.png`;
                iconImg.alt = facility.icon;
                iconImg.onerror = function() { this.style.display='none'; };
                li.appendChild(iconImg);
                li.appendChild(document.createTextNode(`${facility.label} (約${facility.distance.toFixed(0)}m先)`));
                facilitiesList.appendChild(li);
            });
        }
        function clearPlayerSpecificInfo() {
            playerDynmapCoordsDisplay.textContent = '-';
            playerWorldDisplay.textContent = '-';
            roadDisplay.textContent = '-';
            facilitiesList.innerHTML = '<li>プレイヤーを追跡していません。</li>';
        }
    </script>
</body>
</html>